// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

func b
func b
(f: d = B<T>
struct S
protocol c { func a<Int>
class B<T : S<T>: e
0.C
let end = [Void{
func b
case c,
let end = []
{
class d
let start = B<T : c { func b<U : d
class
struct A {
Void{
func b
{
"\([Void{
[Void{
[Void{
{
class
(([Void{
case c
let f = []
func b
struct A {
([]
("
struct S<T where S<T : d = compose(e : S
case c,
class d<T : S<T.e : a
"\("\(f: e
struct S<T where T>: S<Int>
protocol c : S<T: S<T: e) -> Void{
protocol e : d = B<e>(((false)?
{
struct A {
([[]
protocol e : b { func b<e
let start = [Void{
protocol c {
protocol c { func a
protocol e : e
protocol c : S<U : B<e>: d
struct S<e
let start = compose([Void{
("
let start = compose(false)?
class B<T where T>(f: S
let end = [Void{
let start = [Void{
Void{
[[[Void{
class d<U : a<T where T: d<T : d = [Void{
case c
i> c : S<T: d
class
"\([Void{
{
func b<T where T>(f: Any)?
struct A {
{
let end = [Void{
[[[Void{
class B<T where T: b { func c
class B<T where S<T where S
let start = B<Int>: b { func c,
"\([]
protocol e : c {
let f = B<e) -> c : d = T>
Void{
class d
class B<T.e : S
Void{
protocol c { func b
protocol c {
let f = T>
[]
0.e : Any)?
i> c {
protocol c : (f: e
Void{
let start = [Void{
func b<T>
protocol c : (object1: S
Void{
class B<Int>(false)?
let start = compose((e = T.C("
case c,
Void{
func b
"\(false)?
class
case c,
class
"
struct A {
struct A {
{
func b
let end = compose("\(false)?
let start = []
class d
protocol e = B<T where S
Void{
Void{
struct S<T where S<T where S
class B<U : d = [Void{
class B<U : e>(f: c : S
0.C
Void{
protocol c {
func b
protocol c { func a
{
let f = [Void{
{
Void{
class d<Int>: e>: d
case c
let end = [Void{
Void{
func b
i> Void{
let f = []
let f = [Void{
class B<U : e) -> Void{
let start = [Void{
{
class d
{
struct S<Int>
class d<T where S<e>: b { func b<T where S<Int>
"\(e = [[Void{
func a
let end = compose(false).e : ([[Void{
class B<T where T.C
func a<T where S<T : B<T where T>: d = T: b { func b
protocol e : (object1: e
"
Void{
func a
class
protocol c : c {
struct S<T where T>
class
let end = compose([Void{
[]
[Void{
protocol e = B<T where T.e : c {
[[Void{
0.C
func b<U : b { e) ->
