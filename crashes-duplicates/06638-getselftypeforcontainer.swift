// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

let a {
struct d
var d {
struct c<Int>
"\() -> {
var d {
typealias e : Bool)
protocol b : b
protocol b : d {
class d
typealias e : a {
class d<T where S
for c : a {
struct c<T where S<T where S<l : Bool)
typealias b : d
typealias e : d<T where h: Int = compose() -> {
var e
class B<T where B : A
class B<T where T.b : d<l : d {
protocol b : d
let v: A
typealias b : P {
func b: A
func a<T where B {
typealias e : NSObject {
var e
for c : S
protocol B : P {
class B<T where B {
let g = c<T where S<T where T>
class B {
struct c<T where B : P {
let g = f
struct S
typealias e : B<T where h: d {
protocol A {
let a {
"\(t: A? {
class B<T where T>
func a<T where B {
for c : d
protocol B : B<T where T: e: d {
if true {
typealias b : P {
class d
class A {
protocol A {
class B : a {
for c : A : d {
class d<l : b: A? {
for c : d {
let g = f
class B<l : d
func b
struct B<T where T.b : A? {
if true {
func a<Int>
protocol A {
var d {
struct d<l : a {
protocol A {
let g = f
struct d<T where I.b : Bool)
let a {
let a {
protocol B : b
func b
let a {
struct S<T.b : P {
func a<T where S<T where I.b : e
func a<T.b : a {
class B {
class A : b
struct S
protocol A {
enum a<Int>
let v: b
class B : B<T>
protocol B {
protocol A {
struct B<T.b : Int = compose() -> {
if true {
protocol A : S
for c : d {
protocol A : Bool)
class B<T where T>: NSObject {
var d {
class A : P {
var d {
struct d
let v: b
class d<T where S<T where B {
protocol B {
for c : B<T where h: a {
"\() -> {
let a {
for c : b
let v: P {
class d<Int>: P {
protocol B : S<T where I.b : d<T where h: S<T where S<Int>
struct d<T where T: Int = c<T where B {
protocol b : d {
typealias b : d {
class B {
var e
for c : B<T where h: S
protocol A : A? {
enum a<T where B {
struct c<T where T>: A
for c : B<T where S<Int>: A {
let g = compose() -> {
func a<T: A? {
struct c<T>
let g = compose() -> {
struct S<T: A {
"\(t: P {
protocol B : e
class A : d {
protocol B {
protocol b : NSObject {
typealias b : a {
struct c<T where T: d {
var d {
class B : S
struct c<T where S
let a {
protocol A : P {
let v: b: a {
let g = compose() -> {
func b
class B : Int = f
struct d<T where I.Element == f
class d<l : d {
enum a<T where S
struct B<T where B : Int = compose() -> {
protocol b : a {
if true {
struct S
struct B<Int>
func a<T>
class A {
class B : A {
class B {
if true {
class A : NSObject {
let g = compose(t:
