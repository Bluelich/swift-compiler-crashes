// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

var f = c<T : e
func b
var f = 0
protocol c { e
struct d
protocol A : c<T : e>() { func b<I : A
protocol A : c
func a
var f = 0
}
class B
protocol A : b { e
func b<I : e) -> c { func b<I : e
let a {
class B<e>([Void{
protocol c { func b
[]
struct d
protocol c : c
struct d
struct c<I : A.e : a {
}
protocol A {
class B
func b<T where g<I : T, U, A {
protocol A : a {
for c : e
protocol c { func b<I : Bool)
struct d<I : A.e : Bool)
struct d
typealias e == a
struct c<T : b { func b<T : A: d where g: B<I : A: T, A : e>((e : e) -> c : d where g: A
func b<e
struct c
[]
class B<I : BooleanType, U, U, g = g: e>([Void{
typealias e : A: BooleanType, g = g<e
func b<I : Bool)
protocol A : T
protocol A : A.e == c
typealias e : d where A"\([]
}
struct d<T where A.e : e
class a {
struct c
let end = a
typealias e
