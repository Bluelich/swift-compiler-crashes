// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

0.C
<d {
class
static let a {
(e {
func a<d where g: T where H.a
struct A {
struct A {
let start = b
func b
Void{
func b
protocol B : d
class c
case c
typealias f = B)
(([Void{
class
case
<T : e == 0.c,
protocol P {
class
if true {
d
}
}
{
let h = a<T>: c {
}
}
{
d[Void{
func a
protocol P {
}
{
}
let end = []
}
let t: b {
(() as a
func b
protocol c : e {
case c,
}
class
static let a {
typealias f : A {
st
}
Void{
() as a<T : e)
func a<T>: d {
enum b {
func c,
case c] = [ [Void{
case c
}
struct A {
enum b {
struct A {
func g : T where g: f.c
func b
func c
func a<T where B : f.e : A {
case c,
struct c,
d
let t: d
func a<T : c : a {
func c,
struct B<T where g: Any)?
func a
func c,
case c] []
<T {
}
class A {
class A {
(")
d<H : b {
class A {
st
for h = [Void{
let end = B<T where H.C
func d<T where g where H.c,
class A {}
protocol P {
case c] = c,
typealias e : e, leng
func c,
}
class
let t: a<T where g: a {
}
}
protocol A {
struct B<H : e)
}
class a
struct A.e : d
st
case c
typealias e : A.a
class
class
0.a
}
func b
<I : a {
case c
}
case c,
{
protocol A {
struct A {
protocol P {
func b<T where H.C
let a {
class
func a
}
struct d: b { func a")
class A {
class A {
enum B : a {
class
case c,
struct B<v {
func b
func a
}
protocol P {
}
st
0.C
struct A {
([Void{
0.C
<H : f.c] = 1
protocol P {}
func a
struct B<T {
{
typealias e : a<T : Array<H : A {
{
class
func c
class c
case c,
case c
func a"
struct A.g : a"
{
case c
{
protocol e : b { func c
func a
case c,
typealias f : T where g: A.<H : e : e)
case c,
static let end = f.a
struct B<I : Any)
{
struct B<T : a {
st
class A {
var d {
func b
struct B<H : b {
{
protocol e {
{
}
{
{
}
struct d<d {
let t: f.<T where A.c,
([]
protocol a {
func b>: a
func a
0.c
case c,
class a"
enum b {
func b: A.a
[Int] = B<T where H.g = b<d where B : e {
case c,
class
func c,
struct d
func c
extension NSData {
func b
class
protocol e : f.c,
{
typealias e : a {}
let h { func c] ] = [Void{
func c] = b
}
func a
protocol P {
case c
}
protocol a {
{
class A {
var d {
let h = F>([Void{
class
{
[h] = 0.c,
enum b {
protocol a {}
((e : A {
0.c : A :
