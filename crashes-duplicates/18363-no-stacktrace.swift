// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

let a {
{
{
struct B<I : Any))?
case c] = {
typealias e == [Void{
case c: e : NSObject {
var d : b { func b
case c
{
case c
struct c
struct d
class d<T where h: B)?
protocol A {
var d : Any))
struct d<T where g: B)?
func b<T {
init( [ ]
case c] = b
var d { func c: T where T> {
var d {
{
}
class d
{
class B : Any)
class b
{
{
func c] = [Void{
{
static let end = a
}
}
case c
var d : d<I : C {
}
struct d<f = [Void{
case c
}
protocol a {
enum e : b { class b
struc
println
typealias b
struct S<d where g: T where g: Any, A<T where g: Any, d = compose<Q
func c
}
let i: d
S<T where H.e : c: e {
let start = [Void{
{
let i: NSObject {
func p
class a<T>
enum b { func b<T where g: T where h: NSObject {
}
S<T where g: Any, A.c,
d
func c: NSObject {
struct d
va d<I : B? {
struct S<T where g: A {
var d where g: A.b>: B<T where g< > U)?
struct d<T where H.h == [Void{
class
{
class
}
d
}
case c,
struct d<T where T>
class b<f = compose<T.h == 0
{
}
class
class n {
class
static let a {
println() { class B? {
struct d<d {
static let i: B
func f<T>: B? {
{
func c] = e, A<c
let i: A<h == a<T.e : d
struct S<T where B : A? {
struct B<I : d where g: NSManagedObject {
static let a {
var d {
(f(f: e == 0
d<T where T>
class
class n {
struct d<b
case c<T : b { p(T>
class A {
}
}
struct A? {
func e, g: d<T where h: B? {
func b
class
if true {
case c,
}
if true {
() as a
("
struct B?
let a {
S<T where T>
S<d { func c
typealias e : A.c,
{
class
va d<T where H.c
func b<T where h: Any, A.g : Any)
protocol P {
class
case c,
let h = r([Void{
func f: b class A {
class
class B<I : A : Any)"
case c
let a {
class d
}
[ ]
struct S<T.c,
func a
protocol A {
class B<S : d
import Foundation
{
{
enum e : U : NSManagedObject {
case c,
protocol A {
let start = [Void{
let end = [Void{
{
struct B? {
struct d
Void{
}
class
func e() as a
func e, g.b<f = [Void{
class n {
struct S<T where H : T where A.c] = {
var d : Array<f = b<T where T: A {
func f: A {
struct B)?
class b
{
var _ = {
struct B<T where g.h = compose<T where g: c
S<T : e : e where H.c
}
{
struct A : Any, A.c] = B<T where g: B? {
case c
case c,
class A {
{
func e([Void{
func c: d
}
class
struct B)
class
class B<T>
{
}
class
var f =
