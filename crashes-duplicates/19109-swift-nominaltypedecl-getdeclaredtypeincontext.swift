// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

}
}
func e<U {
sel
enum a
{
}
func e<T where g: ( ( (T> ("
func p(
struct S<d {
var _ = b
struct S<T where j: Int = .c<T where T.e {
let a {
protocol b {
let a {
var d : a
}
}
map( "" )
protocol f {
class B<T where g: U : f{ class B : Int = d<d {
enum k {
}
class A : NSObject {
class l: A.B == V
}
func g: B<T where g: Int = .b {
struct D {
typealias b {
}
var _ = {
}
}
func g: A {
let c<l {
func n
let a {
case b( ( )
let a {
enum a
}
class C
{
}
var b {
struct D {
}
struct B {
protocol b {
}
}
func n: A.c: a
typealias C
struct d<T where g: a > : B<D> ("
func e<T where B : f{ class func g: c<l {
}
}
struct d<I : a
class B<T where g: B<T where B {
}
sel
struct d<T where B : B<T where T) -> Void{
}
}
let : A : A : a
{
}
}
enum A {
struct A : NSObject {
NSSet {
func e<f {i {
}
class A {
func e<l {
class a {
enum k {
init( )
enum S<T where B : a {
struct S<d {
}
let a {
{
struct d<T where B : B<T where T>(object : A.b {
typealias b {
}
if true {
struct S<l {
let c: U : a
class A {
}
enum k {
let a {
class A.e {
switch x }
}
}
}
func e<T where j: b(T> {
class B == {
}
}
protocol b = V
struct d<d {
}
func g<T where B : a
}
}
let : U : NSObject {
class B {
}
class a {
class B : a
class B<d {
let a {
{
map( (n: NSObject {
}
}
println(T>
typealias b {
if c == f : a
}
}
{
}
let a {
class a {
enum k {
let a {
{
func e<l {
var _ = .b {
let : A")
if c == f : a
}
enum a
class l: a {
class C
func v: B<T where g: U : U : A {
}
let : B? {
class func p(v<d {
switch x }
class A.e {
}
class func n
var : ( (T.e {
{
}
{
func v<T where g: SequenceType
var _ = d<T where g: a
}
protocol f {
class func d {
let start = V
enum k {
func d : A : A : B<x }
let start = f {
func e<T where T.e : a {
protocol b {
let a = d<T) -> Void{
switch x }
class B<T where B : f{ class a {
}
}
map( ")?
struct D {
println( ( )?
{
class B : f{ class B : A.B : B? {
{
var _ = d<D> : NSObject {
}
enum S<I : B<T.c: B<I : c: a
protocol f {
var : NSObject {
class B? {
{
}
func d {
}
}
let c<T> Void{
init( )
println( )
class func g: NSObject {
var : A.c<U {
struct S<T> {
enum k {
switch x {
var _ = (object : a {
class A<x
