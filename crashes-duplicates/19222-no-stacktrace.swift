// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

for b { func b<c {
for b { func a
var d { func b
( {
case c,
}
let d
let c = a
{
class
class
func d
( {
func b
class
class
protocol b } let {
class
if true {
if true {
protocol C {
[Void{
case
let end = {
case c,
struct c : a {
class
}
b {
}
var d { func b
protocol C {
case c,
func a
for b { func a
{
let a {
var d {
class
var d { func b
{
b } let d: i
func b
}
class
protocol b } let d: d { func a
let c {
{
func l<b
protocol b {
enum e {
protocol C {
class A {
class l {
case
let d: a {
}
class
b : i
for b {
let {
b : a {
{
[Void{
}
class l {
class
var d {
}
func b
for b { func d: a {
case c,
struct B<e
protocol b {
func b
class
case c("
( {
{
{
for
case
func b
struct c {
class l {
func b.b> {
}
protocol C {
( {
let a {
func b> {
func d: d {
func a
case
b } let d
func l<f : b in c,
}
case c("
for b } let d: d {
let end = a
}
case ,
case ,
}
class
case ,
}
let d
func m {
protocol C {
{
protocol b { func a
func d: i
protocol i : d {
class A {
let c = a
protocol i : a {
case c,
{
let end = {
}
{
{
case ,
class
func a
class l {
let d: b { func b
class
case c,
b {
[Void{
protocol C {
class
class
var d {
func m {
struct A {
}
func a
class A {
func b
struct B<c {
protocol b : i
class
case ,
class A {
( {
class
class
class
class
case c("
class
{
class
class
}
case ,
class
case
}
{
func b<e
case c,
let c : b in c,
}
{
case c,
case c,
{
case c,
class
case
class A {
enum e {
let {
func d: a {
for
}
func l<f : b : d {
{
var d { func l<c {
class
[Void{
{
{
protocol c = {
{
[Void{
class A {
struct c {
class
S<b
}
func d: b {
{
case ,
func b
let a {
b in c("
protocol i : a {
for
func b
for
protocol c {
case ,
protocol c : a {
struct B<c {
class
for b { func b> {
b {
case
{
[Void{
{
case ,
struct A {
{
let c = a
func a
}
enum e {
class
}
protocol c = {
[Void{
{
let {
}
class
struct A {
{
case
case
protocol b { func b<f : i
protocol b { func l<f : i
S<c : a {
func b
case c("
for
func d
protocol c : a {
case
enum e {
let end = a
S<c : a {
protocol i : a {
let end = {
protocol c {
{
class
case
protocol i : a {
case ,
S<c = a
if true {
struct c {
class
case ,
let c {
protocol b in c,
case ,
func a
class
class
class
protocol b } let {
func b
for b in c,
for b : a {
{
let end = {
case
