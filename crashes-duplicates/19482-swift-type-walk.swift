// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

enum B {
extension A: T
func a<b: a
class A {
class B
protocol A {
func f: f: I.d
}
func f: a {
protocol A : a<j : d {
struct d
typealias e == 0
extension A? {
struct c<T where h: e)
st
class B
}
protocol A : c: d where H.d.e = compose<d {
protocol A {
class B<T where A.e : I.c {
func a<d {
protocol B {}
protocol c {
typealias f = compose(false)
enum B {
if true {
let c {
struct c: e)
}
typealias e : T
func f.d<T where A? {
}
typealias e = F>(f.e == compose<T where A? {
typealias e = compose<h: e))
protocol P {
typealias e = F>(f: f: a {
<T where A.d<j : a
d<T where A
let f = 0
func f: e
switch x }
func f: f: a {
extension A
typealias f = a<j : d where A
protocol c = 0
let c {
var f = compose<I : a {
protocol A {
}
protocol B {
}
protocol A {
d: (")
protocol B {
switch x }
func f: I.d.c {
if true {}
typealias e = compose<T where H.e : a {
var f = 0
func a<c: d {
func a<j : a {
extension A: d where H.c {
}
enum B {
enum B {
typealias e = f.e : I.d.e = a<I : T
}
struct d: e
protocol P {}
d
d
protocol B {
class A {
protocol B {
func a
func a<j : T
class B<d where A.d: I.d.c {
func a
enum B {
extension A: a<d {
protocol c {
}
var f = 0
<j : I.d.d.c = f.d.e : a<T where H.c = f.e : a
func a
func a
typealias f = compose(false)
let c {
let c {
func a
d: c<c<T where A.e : d {
func f: (false)
class A {
typealias f = f: e)?
struct d<c: f: Any, A: e)?
typealias f = compose<T where H.d.e = compose<T where h: (f: a<h: a<T where A.d<h: (")?
typealias e : a<h: I.d<c<T where A: e)
}
<j : T
enum B : a
func a
}
st
func a<I : a {
protocol A {
protocol c {
struct c: a {}
protocol P {
extension A
struct S<c: (f.e : f: T
func a
protocol P {
typealias f = compose<T where A
struct S<h: B<T where H.d<T where A
typealias f = 0
let f = compose("))
var f = compose<j : (false)
typealias f = compose(f: d where A.d.d<T where A.e == a
if true {
protocol A {
func a
let f = a
func a<j : a<I : a
var f = compose<I : a {
class A {
st
}
<T where H.e = f: c>(")
protocol A {
func f: a
var f = compose<I : e))
typealias e : I.e == F>
protocol A {}
struct S<c: (false)
d
func f: a {
class B
struct S<j : c>(false)
}
st
}
var f = F>(f: c>
if true {
extension A: d {
enum B : a {
class A : e
protocol c {
struct S<c<I : I.d
class A {
if true {
