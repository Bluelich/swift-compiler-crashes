// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

let : N
class B<T where g: B? {
let : P {
var _ = [Void{
{
class
{
{
case
}
case ,
func < {
var c,
func < {
}
class A<T where g: d {
class B
{
var _ = [ [Void{
class
case
func a<T where g: P {
class
case c,
let a > : N
case c,
{
{
{
case c,
}
return m(((() {
}
return m((((((((((((((((((() {
}
case c,
{
class
class A {
let f = [Void{
{
class A<T where g: N
{
enum k {
{
{
case c,
for in {
var _ = [ [Void{
{
class B<j : d {
{
var c
{
return m(() {
func < {
{
{
( ) {
let a {
( {
case ,
class
( ) {
{
let f = [ [Void{
{
{
class A<T: b {
var _ = [ [Void{
case c, let : b {
return m(((((((() {
class
[Void{
}
class A<H : d {
}
class A {
{
case c,
case
var {
{
{
var _ = [Void{
class
}
case c,
var {
class a<T where g: B<H : B? {
let f = [ [Void{
( {
func b
{
enum k {
class
}
}
}
}
var _ = [Void{
class A<T: P {
{
extension NSData {
{
}
case ,
var _ = [Void{
let end = [ [Void{
extension NSData {
extension NSData {
{
func b
class
case
}
}
var c,
{
case
var {
let : P {
class
let f = [Void{
class B
{
class B
class
case ,
case
func < {
class
class
{
func a<j : a {
( {
case c,
let : P {
{
var {
func a
( ) {
}
init( ) {
if true {
class a<T where B : N
func a<H : a > : P {
case c,
func a<H : P {
class
let a {
{
extension NSData {
class A<T where B : b {
}
class A {
}
let : B<T: B? {
return m() {
[Void{
let f = [Void{
let t: P {
class A {
case ,
class
let a {
init( ) {
let : N
[Void{
if true {
init( ) {
init( ) {
class a
init( {
class B<H : d {
init( ) {
class
case
func b
{
class A<T: b {
class
{
var c
[Void{
case c
{
if true {
case c,
let : A {
{
class
func b
{
class a
case
let f = [ [Void{
{
func c,
let end = [ [Void{
let a {
{
}
let f = [Void{
}
class A<T where B : a > : N
func a
if true {
enum k {
case c,
case c,
func < {
{
class
let : P {
return m() {
extension NSData {
class
let : A {
var {
func a
class A<T where B : A {
case
}
case c,
case ,
class a<T where g: A {
class a<j : P {
extension NSData {
case ,
case ,
func b
class
protocol c {
let t: a {
class A {
case ,
case ,
class B<T: d {
let : b {
let : P {
extension NSData {
{
class a<T: A {
