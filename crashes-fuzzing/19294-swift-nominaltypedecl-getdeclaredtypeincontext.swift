// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

func f: A {
class B, leng
class a<T where H.g : T : a {
protocol c {
if true {
class c] = [Void{
var _ = B<T where h: e)
}
var _ = [B<b
struct B<T where h: B<T -> {
var d = a<b
()
let end = a
protocol c {
var d = [Byte][Void{
func f: d where T where B : a<T -> {
}
protocol C {
class c<T where h: e)
func f: e)
struct B<d where T where H.g : c
let start = []
let start = 0.c] = 0.init() as a
struct B, leng
typealias e : c<T where h: d = B
func f: c<T: A {
let start = a
func a<T where T where T where T : B
func f: A {
struct B
class c: c] = a<d where T>
struct B<T where T: A {
let end = 0
[B<T where H.c: c] = [Void{
[]
import Foundation
}
let start = a<T: A {
struct B<T where T where T where T where T : a
func f: a {
}
class a<d = a<b
class c
if true {
let end = [0.c] = B<T where T where B : e)
struct A<T: d = [Void{
protocol c {
class B<T where B : d where T where T>
() as a<T: d: d
typealias e : c<T where T: c] = B
protocol C {
struct A.c<T where T where H.c<T : A {
if true {
if true {
protocol P {
class a
class a<T>
func a<d = B, leng
class B<d = 0.g : A {
func a<T where h: c<T : d = 0
protocol c {
protocol c {
() as a
struct A.c<T : d: c
let start = [B<T where H.c
class c: B
struct B
protocol C {
() as a<T where T where H.c<b
let start = 0.c
}
let start = 0
[B<j : A {
protocol c {
class B
import Foundation
}
}
class d
class d: e)
func a<T -> {
func f: d
let start = a
func a<T where T where B : c<b
import Foundation
class c
typealias e : A {
let end = a
typealias e : A.g : d : d: T where T where h: T : c<d : e!.init()
struct B<j : A {
struct Q<T: d {
class d
let end = a<T where T: A {
}
if true {
protocol C {
func f: A.g : A {
struct B<T where B : d = [][B, leng
protocol P {
class c
var d : A.g : e!.c] = [B, leng
let end = B, leng
let end = [Byte][0.c
protocol c {
[0
class d
}
func f: a {
var d = 0
var d {
protocol C {
func c
[]
let end = [B<d where T : c<d : a {
struct B<T : d where B : e)
let start = [0.c
()
struct A<T where T where T>
class d: d: e)
let end = B, leng
struct Q<T where T>
class d: d: B<j : c
class c<T where B : c
class a<T: B<T where T where T : e)
if true {
typealias e : c<d {
struct B, leng
class d: d: d : d: T : c<T>
}
let end = [Byte][Void{
struct A<d = B<b
let end = [Byte][Byte][Void{
func f:
