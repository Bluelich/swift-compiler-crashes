// Distributed under the terms of the MIT license
// Test case submitted to project by https://github.com/practicalswift (practicalswift)
// Test case found by fuzzing

case c,
class
let A {
case c,
case c,
class c {
let f = Void{
let a {
protocol P {
func a
func d<d : a
case c,
struct Q<T where I : A {
return " " [ {
protocol A {
case c,
struct Q<b: A {
typealias e = "[1)"[1)"[Void{
class
let A {
class
func f = "[1)"[1)"[1)"[1)"[1)"[1)"[Void{
let a {
func a<d: BooleanType
let A {
func f {
class
protocol d {
typealias e = "[Void{
func a
protocol P {
func a: a<T where I : a<d {
case c,
var b {
func b
case c,
return " [ {
class c {
var b {
class
case c,
func a
case c,
func a
var d = Void{
class
func a
protocol P {
(_ = "[Void{
func a<T : c,
if true {
class
func d<T : A {
class
case c,
class A {
func a
func f {
case c,
class c {
func a<b: a {
class
class
func a
class
let a {
func a: a {
let t: c,
class
let h = f<b: a
struct S {
class
let a {
let a = b: a<T : d<T where I : BooleanType
case c,
case ,
case c,
var b {
class
func a
let t: d<T where I : d
class c {
func a
class
class A {
case c,
class
class c {
class c {
func b: a {
func a
let a {
let a {
(_ = "[Void{
case c,
(_ = [1)"[Void{
protocol P {
let a = f<T : a: a: d<d<d: d: A {
var b = "[1)"[Void{
func f {
class
case c,
func a: b = [1)"[Void{
typealias e = "[Void{
class
func b
case c,
protocol d {
struct S {
< T
func a
< T
func b: c,
protocol A {
let t: c,
let a {
var d = b
func b: BooleanType
case c,
let a = f<T where I : b {
class
let a {
case c,
struct Q<b: b = 0
case c,
class A {
class
let t: d: a
class
func a<d : a {
struct S<T where I : A {
(_ = Void{
protocol d = 0
if true {
case c,
case c,
if true {
struct S<T where I : c,
< T
case ,
class
if true {
(_ = "[Void{
let A {
func a<T where I : c,
struct S {
case c,
func d
class
func a
struct Q<T where I : c,
protocol P {
protocol A {
var b {
var b = f<b
class
class c {
var d : c,
func b: A {
struct S {
class
func a<d: d
case c,
let a {
class c {
func a
if true {
case c,
let A {
case c,
case c,
struct S<b: a {
class
let f = Void{
case c,
func a
class
case c,
protocol d : a = f<T where I : b = f<T where I : d: a {
protocol P {
case c,
protocol A {
protocol A {
let a = 0
class
class
func b: b {
case c,
case c,
struct S<T where I : a
class
if true {
var d = f<T where I : c,
let a = [Void{
protocol d : b = [Void{
let A {
class
struct Q<T :
